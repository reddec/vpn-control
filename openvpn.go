package vpnc
import (
	"os/exec"
	"path"
	"path/filepath"
	"text/template"
	"os"
	"errors"
	"io/ioutil"
	"strings"
	"strconv"
)

const vpnConf = `{{with .LocalAddr}}local {{.}}{{end}}
port  {{.Port}}
proto {{.Protocol}}
dev tun
ca   {{.Keys.CA.Certificate}}
cert {{.Keys.Server.Certificate}}
key  {{.Keys.Server.Key}}
dh   {{.Keys.DiffieHellman}}
server 10.8.0.0 255.255.255.0
{{with .PersistIPFile}}ifconfig-pool-persist {{.}}{{end}}
{{if .ClientToClient}}client-to-client{{end}}
keepalive 10 120
{{with .TlsKey}}tls-auth {{.}} 0{{end}}
comp-lzo
persist-key
persist-tun
status openvpn-status.log
verb 3
`

const clientConf = `client
dev tun
proto {{.Protocol}}

{{range .Addresses}}
remote {{.}} {{$.Port}}{{end}}

resolv-retry infinite

ca {{.BaseCACertFile}}
cert {{.ClientCertFile}}
key {{.ClientKeyFile}}
{{if .TlsKey}}
tls-client
tls-auth {{.BaseTLSKeyFile}} 1
auth SHA1
cipher BF-CBC
remote-cert-tls server
{{end}}
comp-lzo
persist-key
persist-tun

status openvpn-status.log
log /var/log/openvpn.log
verb 3
mute 20`

type OpenVPNServer struct {
	LocalAddr      string   // Bind to specific local address. Optional
	Addresses      []string // Public addresses of server. Required for client configuration
	Port           uint16   // Public port
	Protocol       string   // Network protocol. Could be tcp or udp
	Keys           KeyFiles // Keys files generated by easy-rsa: CA, server.key and e.t.c.
	PersistIPFile  string   // List of clients and their static ips. Optional
	TlsKey         string   // Location of TLS key. Automatically sets after BuildTLSKey(). If set, server and clients config will use TLS
	ClientToClient bool     // Enable client to client communication
}

// Base file name of TLS key
func (ovpn OpenVPNServer) BaseTLSKeyFile() string {
	return path.Base(ovpn.TlsKey)
}

// Base file name of CA certificate
func (ovpn OpenVPNServer) BaseCACertFile() string {
	return path.Base(ovpn.Keys.CA.Certificate)
}

// Append static ip for client to PersistIPFile. It doesn't check unique (use ListStaticIP before)
func (ovpn OpenVPNServer) AddStaticIP(client string, ip string) error {
	f, err := os.OpenFile(ovpn.PersistIPFile, os.O_APPEND | os.O_WRONLY, 0600)
	if err != nil {
		return err
	}
	defer f.Close()
	if _, err = f.WriteString(client + "," + ip + "\n"); err != nil {
		return err
	}
	return nil
}

// Read and parse PersistIPFile - list of client and static ip pairs
func (ovpn OpenVPNServer) ListStaticIP() (map[string]string, error) {
	data, err := ioutil.ReadFile(ovpn.PersistIPFile)
	if err != nil {
		return nil, err
	}
	ips := make(map[string]string)
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		kv := strings.Split(line, ",")
		if len(kv) == 2 {
			ips[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
		}
	}
	return ips, nil
}

// Read, parse, exclude client and save PersistIPFile
func (ovpn OpenVPNServer) RemoveStaticIP(client string) error {
	items, err := ovpn.ListStaticIP()
	if err != nil {
		return err
	}
	delete(items, client)
	f, err := os.Create(ovpn.PersistIPFile)
	if err != nil {
		return err
	}
	defer f.Close()
	for klient, ip := range items {
		if _, err = f.WriteString(klient + "," + ip + "\n"); err != nil {
			return err
		}
	}
	return nil
}

// Check required parameters like port, protocol and others
func (ovpn OpenVPNServer) CheckRequiredFields() error {
	if ovpn.Port == 0 {
		return errors.New("Port must be non-zero positive value")
	}
	if ovpn.Protocol != "udp" && ovpn.Protocol != "tcp" {
		return errors.New("Unknown protocol " + ovpn.Protocol + ": must be udp or tcp")
	}
	if ovpn.Keys.CA.Certificate == "" || ovpn.Keys.Server.Key == "" || ovpn.Keys.DiffieHellman == "" || ovpn.Keys.Server.Certificate == "" {
		return errors.New("CA cert, Server key/cert and Diffie-Hellman pem must be")
	}
	return nil
}

// Create initial server configuration file into targetDir
func (ovpn OpenVPNServer) InitialConfig(targetDir string) error {
	if err := ovpn.CheckRequiredFields(); err != nil {
		return err
	}
	target, err := filepath.Abs(targetDir)
	if err != nil {
		return err
	}
	err = os.MkdirAll(target, 0755)
	if err != nil {
		return err
	}
	if ovpn.PersistIPFile != "" {
		ipp, err := filepath.Abs(ovpn.PersistIPFile)
		if err != nil {
			return err
		}
		err = os.MkdirAll(filepath.Dir(ipp), 0755)
		if err != nil {
			return err
		}
		ovpn.PersistIPFile = ipp
		f, err := os.Create(ovpn.PersistIPFile)
		if err != nil {
			return err
		}
		f.Close()
	}
	target = path.Join(target, "server.conf")
	templ, err := template.New("").Parse(vpnConf)
	if err != nil {
		return err
	}
	f, err := os.Create(target)
	if err != nil {
		return err
	}
	defer f.Close()
	return templ.Execute(f, ovpn)
}

// Create TLS key into keysDir as ta.key file and sets TlsKey property.
// This enables TLS connection for server and future clients
func (ovpn *OpenVPNServer) BuildTLSKey(keysDir string) error {
	v, err := filepath.Abs(keysDir)
	if err != nil {
		return err
	}
	err = os.MkdirAll(keysDir, 0755)
	if err != nil {
		return err
	}
	cmd := exec.Command("openvpn", "--genkey", "--secret", path.Join(v, "ta.key"))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err = cmd.Run(); err == nil {
		ovpn.TlsKey = path.Join(v, "ta.key")
	}
	return err
}

// Create client configuration based on easy-rsa keys. It copies (really it links) all required files into targetDir
// and creates client.conf
func (ovpn OpenVPNServer) BuildClientConf(targetDir string, clientCert, clientKey string) error {
	if len(ovpn.Addresses) == 0 {
		return errors.New("No public addresses")
	}
	if err := ovpn.CheckRequiredFields(); err != nil {
		return err
	}
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		return err
	}
	err := os.Link(ovpn.Keys.DiffieHellman, path.Join(targetDir, path.Base(ovpn.Keys.DiffieHellman)))
	if err != nil {
		return err
	}
	err = os.Link(ovpn.Keys.Server.Certificate, path.Join(targetDir, path.Base(ovpn.Keys.Server.Certificate)))
	if err != nil {
		return err
	}
	err = os.Link(ovpn.Keys.CA.Certificate, path.Join(targetDir, path.Base(ovpn.Keys.CA.Certificate)))
	if err != nil {
		return err
	}
	if ovpn.TlsKey != "" {
		err = os.Link(ovpn.TlsKey, path.Join(targetDir, path.Base(ovpn.TlsKey)))
		if err != nil {
			return err
		}
	}
	err = os.Link(clientCert, path.Join(targetDir, path.Base(clientCert)))
	if err != nil {
		return err
	}
	err = os.Link(clientKey, path.Join(targetDir, path.Base(clientKey)))
	if err != nil {
		return err
	}
	target := path.Join(targetDir, "client.conf")
	templ, err := template.New("").Parse(clientConf)
	if err != nil {
		return err
	}
	f, err := os.Create(target)
	if err != nil {
		return err
	}
	defer f.Close()
	params := struct {OpenVPNServer
					  ClientCertFile string
					  ClientKeyFile  string    }{}
	params.OpenVPNServer = ovpn
	params.ClientCertFile = path.Base(clientCert)
	params.ClientKeyFile = path.Base(clientKey)
	return templ.Execute(f, params)
}

// Read necessary parameters from OpenSSL server configuration file
func OpenServerConf(serverConf string) (OpenVPNServer, error) {
	server := OpenVPNServer{}
	content, err := ioutil.ReadFile(serverConf)
	if err != nil {
		return server, err
	}
	lines := strings.Split(string(content), "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || line[0] == '#' || line[0] == ';' {
			continue
		}
		if line == "client-to-client" {
			server.ClientToClient = true
			continue
		}

		kv := strings.SplitN(line, " ", 2)
		if len(kv) < 2 {
			continue
		}
		val := strings.TrimSpace(kv[1])
		switch strings.TrimSpace(kv[0]) {
		case "port":
			prt, err := strconv.ParseUint(val, 10, 16)
			if err != nil {
				return server, err
			}
			server.Port = uint16(prt)
		case "proto": server.Protocol = val
		case "local": server.LocalAddr = val
		case "ca": server.Keys.CA.Certificate = val
		case "cert": server.Keys.Server.Certificate = val
		case "key": server.Keys.Server.Key = val
		case "dh": server.Keys.DiffieHellman = val
		case "ifconfig-pool-persist": server.PersistIPFile = val
		case "tls-auth": server.TlsKey = strings.Split(val, " ")[0] //Chop direction
		}
	}
	return server, nil
}